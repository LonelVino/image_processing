Usage:
  "kdu_compress ...
   -i <file 1>,...
       One or more input files. If multiple files are provided, they must be
       separated by commas. Any spaces will be treated as part of the file
       name.  Currently accepted image file formats are RAW, BMP, PBM, PGM and
       PPM.  For raw files, the sample bits must be in the least significant
       bit positions of an 8, 16, 24 or 32 bit word, depending on the
       bit-depth.  Unused MSB's in each word are entirely disregarded.  The
       word organization is big-endian. Also, with raw files, the dimensions
       must be provided separately using `Sdims' or any other appropriate
       combination of SIZ-type parameters.
   -o <compressed file -- raw code-stream, JP2 or JPX file>
       Name of file to receive the compressed code-stream.  If the file name
       has a ".jp2" suffix (not case sensitive), the code-stream will be
       wrapped up inside the JP2 file format.  If the file name has a ".jpx" or
       ".jpf" suffix (not case sensitive), the code-stream will be wrapped up
       inside the more sophisticated JPX file format, with a single compositing
       layer.  In either case, the first 3 source image components will be
       treated as sRGB colour channels (red, green then blue) and the remainder
       will be identified as auxiliary undefined components in the JP2/JPX
       file, unless there are less than 3 colours, or a separate colour space
       is identified via the `-jp2_space' and/or `-jpx_space' arguments.
          If an input file defines a colour palette (quite common with BMP
       files), this will be preserved through the JP2/JPX file format, and
       samples will be correctly de-palettized by conformant JP2/JPX readers. 
       If there are fewer than 3 components available (taking any palette into
       account), the first component will be identified as a luminance
       component with the sRGB gamma and any remaining component will be
       identified as an auxiliary undefined channel.  Again, these default
       decisions may be overridden by the `-jp2_space' and/or `-jpx_space'
       arguments.
   -roi {<top>,<left>},{<height>,<width>} | <PGM image>,<threshold>
       Establish a region of interest (foreground) to be coded more precisely
       and/or earlier in the progression than the rest of the image
       (background).  This argument has no effect unless the "Rshift" attribute
       is also set.  The "Rlevels" attribute may also be used to control the
       number of DWT levels which will be affected by the ROI information.
          The single parameter supplied with this argument may take one of two
       forms.  The first form provides a simple rectangular region of interest,
       specified in terms of its upper left hand corner coordinates
       (comma-separated and enclosed in curly braces) and its dimensions (also
       comma-separated and enclosed in braces).  All coordinates and dimensions
       are expressed relative to the origin and dimensions of the high
       resolution grid (or canvas), using real numbers in the range 0 to 1. If
       the original image is to be rotated during compression (see `-rotate'),
       the coordinates supplied here are to be interpreted with respect to the
       orientation of the image being compressed.
          The second form for the single parameter string supplied with the
       `-roi' argument involves a named (PGM) image file, separated by a comma
       from an ensuing real-valued threshold in the range 0 to 1.  In this
       case, the image is scaled (interpolated) to fill the region occupied by
       each image component.  Pixel values whose relative amplitude exceeds the
       threshold identify the foreground region.
   -rate -|<bits/pel>,<bits/pel>,...
       One or more bit-rates, expressed in terms of the ratio between the total
       number of compressed bits (including headers) and the product of the
       largest horizontal and  vertical image component dimensions.  A dash,
       "-", may be used in place of the first bit-rate in the list to indicate
       that the final quality layer should include all compressed bits. 
       Specifying a very large rate target is fundamentally different to using
       the dash, "-", because the former approach may cause the incremental
       rate allocator to discard terminal coding passes which do not lie on the
       rate-distortion convex hull.  This means that reversible compression
       might not yield a truly lossless representation if you specify `-rate'
       without a dash for the first rate target, no matter how large the
       largest rate target is.
          If "Clayers" is not used, the number of layers is set to the number
       of rates specified here. If "Clayers" is used to specify an actual
       number of quality layers, one of the following must be true: 1) the
       number of rates specified here is identical to the specified number of
       layers; or 2) one, two or no rates are specified using this argument. 
       When two rates are specified, the number of layers must be 2 or more and
       intervening layers will be assigned roughly logarithmically spaced
       bit-rates. When only one rate is specified, an internal heuristic
       determines a lower bound and logarithmically spaces the layer rates over
       the range.
   -slope <layer slope>,<layer slope>,...
       If present, this argument provides rate control information directly in
       terms of distortion-length slope values, overriding any information
       which may or may not have been supplied via a `-rate' argument.  If the
       number of quality layers is  not specified via a `Clayers' argument, it
       will be deduced from the number of slope values.  Slopes are inversely
       related to bit-rate, so the slopes should decrease from layer to layer. 
       The program automatically sorts slopes into decreasing order so you need
       not worry about getting the order right.  For reference we note that a
       slope value of 0 means that all compressed bits will be included by the
       end of the relevant layer, while a slope value of 65535 means that no
       compressed bits will be included in the  layer.  The list of layer slope
       values must include at least one non-zero value.
   -full -- forces encoding and storing of all bit-planes.
       By default, the system incrementally constructs conservative estimates
       of the final rate allocation parameters and uses these to skip coding
       passes which are very likely to be discarded during rate allocation.  It
       also discards any compressed code-bytes which we know we will not be
       needing on a regular basis, so as to conserve memory.  For large images,
       the memory consumption can approach the final compressed file size.  You
       might like to use the `-full' argument if you are compressing an image
       with highly non-uniform statistics.
   -precise -- forces the use of 32-bit representations.
       By default, 16-bit data representations will be employed for sample data
       processing operations (colour transform and DWT) whenever the image
       component bit-depth is sufficiently small.
   -tolerance <percent tolerance on layer sizes given using `-rate'>
       This argument modifies the behaviour of the `-rate' argument slightly,
       providing a tolerance specification on the achievement of the cumulative
       layer bit-rates given by that argument.  It has no effect if layer
       construction is controlled using the `-slope' argument.  The rate
       allocation algorithm will attempt to find a distortion-length slope such
       that the bit-rate, R_L, associated with layer L is in the range
       T_L*(1-tolerance/100) <= R_L <= T_L, where T_L is the target bit-rate,
       which is the difference between the cumulative bit-rate at layer L and
       the cumulative bit-rate at layer L-1, as specified in the `-rate' list. 
       Note that the tolerance is given as a percentage, that it affects only
       the lower bound, not the upper bound on the bit-rate, and that the
       default tolerance is 0.  If it is not possible to satisfy both bounds on
       the layer bit-rate exactly, the layer will be assigned the largest size
       which is consistent with the upper bound, if possible.
   -flush_period <incremental flush period, measured in image lines>
       By default, the system waits until all compressed data has been
       generated, by applying colour transforms, wavelet transforms and block
       encoding processes to the entire image, before any of this compressed
       data is actually written to the output file.  The present argument may
       be used to request incremental flushing, where the compressed data is
       periodically flushed to the output file, thereby avoiding the need for
       internal buffering of the entire compressed image.  The agument takes a
       single parameter, identifying the minimum number of image lines which
       should be processed before each attempt to flush new code-stream data. 
       The actual period may be larger, if insufficient data has been generated
       to progress the code-stream.
          Incremental flushing may be used with either `-slope' controlled
       quality layers, or `-rate' driven quality layers; however, with
       rate-driven quality layers you should be particularly careful to keep
       the flushing period large enough to give the rate control algorithm a
       decent amount of compressed data to perform effective rate control. 
       Generally a period of at least 1000 or 2000 image lines should be used
       for rate driven flushing.
          You should be aware of the fact that incremental flushing is possible
       only on tile boundaries or when the packet progression sequence is
       spatially progressive (PCRL), with sufficiently small precincts.  The
       vertical dimension of precincts in the lowest resolution levels must be
       especially tightly controlled, particularly if you have a large number
       of DWT levels.  As an example, with `Clevels=6', the following precinct
       dimensions would be a good choice for use with 32x32 code-blocks:
       `Cprecincts={256,256},{128,128},{64,64},{32,64},{16,64},{8,64},{4,64}'.
   -no_info -- prevents the inclusion of layer info in COM segments.
       From v3.3, a code-stream COM (comment) marker segment is included in the
       main header to record the distortion-length slope and the size of each
       quality layer which is generated.  If you wish to make the file as small
       as possible and are working with small images, you may wish to disable
       this feature by specifying the `-no_info' flag.
   -no_weights -- target MSE minimization for colour images.
       By default, visual weights will be automatically used for colour imagery
       (anything with 3 compatible components).  Turn this off if you want
       direct minimization of the MSE over all reconstructed colour components.
   -no_palette
       This argument is meaningful only when reading palettized imagery and
       compressing to a JP2/JPX file.  By default, the palette will be
       preserved in the JP2/JPX file and only the palette indices will be
       compressed.  In many cases, it may be more efficient to compress the RGB
       data as a 24-bit continuous tone image. To make sure that this happens,
       select the `-no_palette' option.
   -jp2_space <sLUM|sRGB|sYCC|iccLUM|iccRGB>[,<parameters>]
       You may use this to explicitly specify a JP2 compatible colour space
       description to be included in a JP2/JPX file.  If the colour space is
       `sLUM' or `iccLUM', only one colour channel will be defined, even if the
       codestream contains 3 or more components.  The argument is illegal
       except when the output file has the ".jp2", ".jpx" or ".jpf" suffix, as
       explained above.  Note that for JPX files (those having a ".jpx" or
       ".jpf" suffix), the `-jpx_space' argument may be supplied as an
       alternative or in addition to this argument to provide richer colour
       descriptions or even multiple colour descriptions.  The pesent argument
       must be followed by a single string consisting of one of 5 colour space
       names, possibly followed by a comma-separated list of parameters.
          If the space is "iccLUM", two parameters must follow, `gamma' and
       `beta', which identify the tone reproduction curve.  As examples, the
       sRGB space has gamma=2.4 and beta=0.055, while NTSC RGB has gammma=2.2
       and beta=0.099.  A pure power law has beta=0, but is not recommended due
       to the ill-conditioned nature of the resulting function around 0.
          If the space is "iccRGB", 9 parameters must follow in the comma
       separated list.  The first two of these are the gamma and beta values,
       as above.  The next 2 parameters hold the X and Y chromaticity
       coordinates of the first (typically red) primary colour.  Similarly, the
       next 4 parameters hold the X,Y coordinates of the second (typically
       green) and third (typically blue) primary colour.  The final parameter
       must be one of the two strings "D50" or "D65", identifying the
       illuminant.  The present function assumes that equal amounts of all 3
       primary colours produce the neutral (white) associated with this
       illuminant.
   -jpx_space <enumerated colour space>,[<prec>,<approx>]
       This argument may be used only when writing JPX files (those with a
       ".jpx" or ".jpf" suffix).  Although JPX files may contain arbitrary ICC
       profiles, we do not provide the capability to include these from the
       command line.  Instead, we list here only the enumerated colour space
       options defined by JPX.  If `-jp2_space' is also supplied, multiple
       colour descriptions will be written, with the JP2 compatible description
       appearing first.  If the `prec' and `approx' parameters are omitted from
       the parameter list, they default to 0.  Otherwise, the supplied
       precedence must lie in the range -128 to +127 and the supplied
       approximation level must lie in the range 0 to 4.  The following
       enumerated colour space names are recognized:
           `bilevel1', `bilevel2', `YCbCr1', `YCbCr2', `YCbCr3', `PhotoYCC',
           `CMY', `CMYK', `YCCK', `CIELab', `CIEJab', `sLUM', `sRGB', `sYCC',
           `esRGB', `esYCC', `ROMMRGB', `YPbPr60',  `YPbPr50'.
   -jp2_aspect <aspect ratio of high-res canvas grid>
       Identifies the aspect ratio to be used by a conformant JP2/JPX reader
       when rendering the decompressed image to a display, printer or other
       output device.  The aspect ratio identifies ratio formed by dividing the
       vertical grid spacing by the horizontal grid spacing, where the relevant
       grid is that of the high resolution canvas.  Sub-sampling factors
       determine the number of high resolution canvas grid points occupied by
       any given image component sample in each direction.  By default
       conformant JP2/JPX readers are expected to assume a 1:1 aspect ratio on
       the high resolution canvas, so that the use of non-identical
       sub-sampling factors for an image component implies a required aspect
       ratio conversion after decompression.
   -jp2_alpha -- treat 2'nd or 4'th image component as alpha
       Use this argument if you want one of the image components to be treated
       as an alpha channel for the pixels whose colour is represented by the
       preceding components.  If the colour space is grey-scale (see
       `-jp2_space'), component 0 represents the intensity and component 1
       represents alpha.  More generally, if the colour space involves C colour
       channels, the first C components represent these colour channels and the
       next one represents alpha.
   -jp2_box <file 1>[,<file 2>[,...]]
       This argument provides a crude method for allowing extra boxes to be
       inserted into a JP2 or JPX file.  The extra boxes are written after the
       main file header boxes, but before the contiguous code-stream box.  The
       argument takes a comma-separated list of file names, without any
       intervening space.  Each file represents a single top-level box, whose
       box-type is found in the first 4 characters of the file, and whose
       contents start immediately after the first new-line character and
       continue until the end of the file.  The first line of the file (the one
       containing the box-type characters and preceding the box contents)
       should not be more than 128 characters long.  Each file may contain
       arbitrary binary or ASCII data, but is always opened as binary.
   -rotate <degrees>
       Rotate source image prior to compression. Must be multiple of 90
       degrees.
   Sprofile={<int>}
       Restricted profile to which the code-stream must conform.  The value
       must be an integer in the range 0 to 2, where Profile-0 is the most
       restrictive and Profile-2 places no restrictions on the code-stream
       other than those defined in ISO/IEC 15444-1 (JPEG2000, Part 1).  If the
       profile is insufficient, the system will generate a warning at the point
       where it first encounters an inconsistency -- this might not occur until
       near the end of the processing in certain rare circumstances.
           [Defaults to Profile-2.]
   Ssize={<int>,<int>}
       Canvas dimensions: vertical dimension first.
           [For compressors, this will normally be derived from the dimensions
           of the individual image components. Explicitly supplying the canvas
           dimensions may be desirable if the source image files do not
           indicate their dimensions, or if custom sub-sampling factors are
           desired.]
   Sorigin={<int>,<int>}
       Image origin on canvas: vertical coordinate first.
           [Defaults to {0,0}, or the tile origin if one is given]
   Stiles={<int>,<int>}
       Tile partition size: vertical dimension first.
           [Defaults to {0,0}]
   Stile_origin={<int>,<int>}
       Tile origin on the canvas: vertical coordinate first.
           [Defaults to {0,0}]
   Scomponents={<int>}
       Number of image components.
           [For compressors, this will normally be deduced from the number and
           type of image files supplied to the compressor.]
   Ssigned={<yes/no>},...
       Indicates whether each image component contains signed or unsigned
       sample values.
           [For compressors, this will normally be deduced from the image files
           supplied to the compressor, but may be explicitly set if raw input
           files are to be used. The last supplied identifier is repeated
           indefinitely for all remaining components.]
   Sprecision={<int>},...
       Indicates the bit-depth of each image component.
           [For compressors, this will normally be deduced from the image files
           supplied to the compressor, but may be explicitly set if raw input
           files are to be used. The last supplied value is repeated
           indefinitely for all remaining components.]
   Ssampling={<int>,<int>},...
       Indicates the sub-sampling factors for each image component. In each
       record, the vertical factor appears first, followed by the horizontal
       sub-sampling factor. The last supplied record is repeated indefinitely
       for all remaining components.
           [For compressors, a suitable set of sub-sampling factors will
           normally be deduced from the individual image component dimensions.]
   Sdims={<int>,<int>},...
       Indicates the dimensions (vertical, then horizontal) of each individual
       image component. The last supplied record is repeated indefinitely for
       all remaining components.
           [For compressors, the image component dimensions will normally be
           deduced from the image files supplied to the compressor, but may be
           explicitly set if raw input files are to be used.]
   Cycc[:<T>]={<yes/no>}
       RGB to Luminance-Chrominance conversion?
           [Default is to convert 3 component images]
   Clayers[:<T>]={<int>}
       Number of quality layers. May not exceed 16384.
           [Default is 1]
   Cuse_sop[:<T>]={<yes/no>}
       Include SOP markers (i.e., resync markers)?
           [Default is no SOP markers]
   Cuse_eph[:<T>]={<yes/no>}
       Include EPH markers (marker end of each packet header)?
           [Default is no EPH markers]
   Corder[:<T>]={ENUM<LRCP,RLCP,RPCL,PCRL,CPRL>}
       Default progression order (may be overridden by Porder).  The four
       character identifiers have the following interpretation: L=layer;
       R=resolution; C=component; P=position. The first character in the
       identifier refers to the index which progresses most slowly, while the
       last refers to the index which progresses most quickly.
           [Default is LRCP]
   Calign_blk_last[:<T>]={<yes/no>,<yes/no>}
       If "yes", the code-block partition is aligned so that the last sample in
       each nominal block (ignoring the effect of boundaries) is aligned at a
       multiple of the block dimension (a power of 2).  Equivalently, the first
       sample in each nominal block lies at a location which is a multiple of
       the block dimension, plus 1. By default (i.e., "no"), the first sample
       of each block is aligned at a multiple of the block dimension. The
       alignment is specified separately for both dimensions, with the vertical
       dimension specified first.
   Clevels[:<TC>]={<int>}
       Number of wavelet decomposition levels, or stages.  May not exceed 32.
           [Default is 5]
   Creversible[:<TC>]={<yes/no>}
       Reversible compression?
           [Default is irreversible]
   Ckernels[:<TC>]={ENUM<W9X7,W5X3>}
       Wavelet kernels to use.
           [Default is W5X3 for reversible compression and W9X7 for
           irreversible compression]
   Cuse_precincts[:<TC>]={<yes/no>}
       Explicitly specify whether or not precinct dimensions are supplied.
           [Default is "no" unless `Cprecincts' is used]
   Cprecincts[:<TC>]={<int>,<int>},...
       Precinct dimensions (must be powers of 2). Multiple records may be
       supplied, in which case the first record refers to the highest
       resolution level and subsequent records to lower resolution levels. The
       last specified record is used for any remaining lower resolution
       levels.Inside each record, vertical coordinates appear first.
   Cblk[:<TC>]={<int>,<int>}
       Nominal code-block dimensions (must be powers of 2, no less than 4 and
       no greater than 1024). Actual dimensions are subject to precinct, tile
       and image dimensions. Vertical coordinates appear first.
           [Default block dimensions are {64,64}]
   Cmodes[:<TC>]={FLAGS<BYPASS|RESET|RESTART|CAUSAL|ERTERM|SEGMARK>}
       Block coder mode switches. Any combination is legal.
           [By default, all mode switches are turned off]
   Cweight[:<TC>]={<float>}
       Multiplier for subband weighting factors (see `Clev_weights' and
       `Cband_weights' below).  Scaling all the weights by a single quantity
       has no impact on their relative significance.  However, you may supply a
       separate weight for each component, or even each tile-component,
       allowing you to control the relative signicance of image components or
       tile-components in a simple manner.
   Clev_weights[:<TC>]={<float>},...
       Weighting factors for each successive resolution level, starting from
       the highest resolution and working down to the lowest (but not including
       the LL band!!). The last supplied weight is repeated as necessary. 
       Weight values are squared to obtain energy weights for weighted MSE
       calculations.  The LL subband always has a weight of 1.0, regardless of
       the number of resolution levels.  However, the weights associated with
       all subbands, including the LL band, are multiplied by the value
       supplied by `Cweight', which may be specialized to individual components
       or tile-components.
   Cband_weights[:<TC>]={<float>},...
       Weighting factors for each successive subband, starting from the highest
       frequency subbands and working down (i.e., HH1, LH1, HL1, HH2, ...). The
       last supplied weight is repeated as necessary for all remaining subbands
       (except the LL band). If `Clev_weights' is also supplied, both sets of
       weighting factors are combined (multiplied).  Weight values are squared
       to obtain energy weights for weighted MSE calculations.  The LL subband
       always has a weight of 1.0, which avoids problems which may occur when
       image components or tiles have different numbers of resolution levels. 
       To modify the relative weighting of components or tile-components,
       including their LL subbands, use the `Cweight' option; its weighting
       factors are multiplied by those specified using `Cband_weights' and
       `Clev_weights'.
   Qguard[:<TC>]={<int>}
       Number of guard bits to prevent overflow in the magnitude bit-plane
       representation. Typical values are 1 or 2.
           [Default is 1]
   Qderived[:<TC>]={<yes/no>}
       Quantization steps derived from LL band parameters? If "yes", all
       quantization step sizes will be related to the LL subband's step sizes
       through appropriate powers of 2 and only the LL band step size will be
       written in code-stream markers. Otherwise, a separate step size will be
       recorded for every subband. You cannot use this option with reversible
       compression.
           [Default is not derived]
   Qstep[:<TC>]={<float>}
       Base step size to be used in deriving irreversible quantization step
       sizes for every subband. The base step parameter should be in the range
       0 to 2.
           [Default is 1/256]
   Qabs_steps[:<TC>]={<float>},...
       Absolute quantization step sizes for each subband, expressed as a
       fraction of the nominal dynamic range for that subband. The nominal
       range is equal to 2^B (B is the image sample bit-depth) multiplied by
       the DC gain of each low-pass subband analysis filter and the AC gain of
       each high-pass subband analysis filter, involved in the construction of
       the relevant subband. The bands are described one by one, in the
       following sequence: LL_D, HL_D, LH_D, ..., HL_1, LH_1, HH_1. Here, D
       denotes the number of DWT levels. A single step size must be supplied
       for every subband (there is no extrapolation), except in the event that
       `Qderived' is set to "yes" -- then, only one parameter is allowed,
       corresponding to the LL_D subband.
           [For compressors, the absolute step sizes are ignored if `Qstep' has
           been used.]
   Qabs_ranges[:<TC>]={<int>},...
       Number of range bits used to code each subband during reversible
       compression.  Subbands appear in the sequence, LL_D, HL_D, LH_D, ...,
       HL_1, LH_1, HH_1, where D denotes the number of DWT levels.  The number
       of range bits for a reversibly compressed subband, plus the number of
       guard bits (see `Qguard'), is equal to 1 plus the number of magnitude
       bit-planes which are used for coding its samples.
           [For compressors, most users will accept the default policy, which
           sets the number of range bits to the smallest value which is
           guaranteed to avoid overflow or underflow in the bit-plane
           representation, assuming that the RCT (colour transform) is used. 
           If explicit values are supplied, they must be given for each and
           every subband.]
   Rshift[:<TC>]={<int>}
       Region of interest up-shift value.  All subband samples which are
       involved in the synthesis of any image sample which belongs to the
       foreground region of an ROI mask will be effectively shifted up (scaled
       by two the power of this shift value) prior to quantization.  The region
       geometry is specified independently and is not explicitly signalled
       through the code-stream; instead, this shift must be sufficiently large
       to enable the decoder to separate the foreground and background on the
       basis of the shifted sample amplitudes alone.  You will receive an
       appropriate error message if the shift value is too small.
           [Default is 0]
   Rlevels[:<TC>]={<int>}
       Number of initial (highest frequency) DWT levels through which to
       propagate geometric information concerning the foreground region for ROI
       processing.  Additional levels (i.e., lower frequency subbands) will be
       treated as belonging entirely to the foreground region.
           [Default is 4]
   Rweight[:<TC>]={<float>}
       Region of interest significance weight.  Although this attribute may be
       used together with `Rshift', it is common to use only one or the other. 
       All code-blocks whose samples contribute in any way to the
       reconstruction of the foreground region of an ROI mask will have their
       distortion metrics scaled by the square of the supplied weighting
       factor, for the purpose of rate allocation.  This renders such blocks
       more important and assigns to them relatively more bits, in a manner
       which is closely related to the effect of the `Clevel_weights' and
       `Cband_weights' attributes on the importance of whole subbands.  Note
       that this region weighting strategy is most effective when working with
       large images and relatively small code-blocks (or precincts).
           [Default is 1, i.e., no extra weighting]
   Porder[:<T>]={<int>,<int>,<int>,<int>,<int>,ENUM<LRCP,RLCP,RPCL,PCRL,CPRL>},
   ...
       Progression order change information.  The attribute may be applied
       globally (main header), or in a tile-specific manner (tile-part header).
        In this latter case, multiple instances of the attribute may be
       supplied for any given tile, which will force the generation of multiple
       tile-parts for the tile (one for each instance of the `Porder'
       attribute).  As with all attributes, tile specific forms are specified
       by appending a suffix of the form ":T<tnum>" to the attribute name,
       where <tnum> stands for the tile number, starting from 0.  Each instance
       of the attribute may contain one or more progression records, each of
       which defines the order for a collection of packets. Each record
       contains 6 fields. The first two fields identify inclusive lower bounds
       for the resolution level and image component indices, respectively. The
       next three fields identify exclusive upper bounds for the quality layer,
       resolution level and image component indices, respectively. All indices
       are zero-based, with resolution level 0 corresponding to the LL_D
       subband. The final field in each record identifies the progression order
       to be applied within the indicated bounds. This order is applied only to
       those packets which have not already been sequenced by previous records
       or instances.
   CRGoffset={<float>,<float>},...
       Provides additional component registration offsets. The offsets add to
       those implied by the canvas coordinate system and should only be used
       when canvas coordinates (notably `Ssize', `Soffset' and `Ssampling')
       cannot be found, which adequately reflect the relative displacement of
       the components. Each record specifies offsets for one component, with
       the vertical offset appearing first. Offsets must be in the range 0
       (inclusive) to 1 (exclusive) and represent a fraction of the relevant
       component sub-sampling factor (see `Ssampling'). The last supplied
       record is repeated as needed to recover offsets for all components. 
   ORGtparts[:<T>]={FLAGS<R|L|C>}
       Controls the division of each tile's packets into tile-parts.  The
       attribute consists of one or more of the flags, `R', `L' and `C',
       separated by the vertical bar character, `|'.  If the `R' flag is
       supplied, tile-parts will be introduced as necessary to ensure that each
       tile-part consists of packets from only one resolution level.  If `L' is
       supplied, tile-parts are introduced as necessary to ensure that each
       tile-part consists of packets from only one quality layer.  Similarly,
       if the `C' flag is supplied, each tile-part will consist of packets from
       only one component.  Note that the cost of extra tile-part headers will
       not be taken into account during rate control, so that the code-stream
       may end up being a little larger than you expect.
           [By default, tile-part boundaries are introduced only as required by
           the presence of multiple "Porder" attribute specifications.]
   ORGgen_plt[:<T>]={<yes/no>}
       Requests the insertion of packet length information in the header of all
       tile-parts associated with tiles for which this attribute is turned on
       (has a value of "yes").  The PLT marker segments written into the
       relevant tile-part headers will hold the lengths of those packets which
       belong to the same tile-part.  Note that the cost of any PLT marker
       segments generated as a result of this attribute being enabled will not
       be taken into account during rate allocation.  This means that the
       resulting code-streams will generally be a little larger than one might
       expect; however, this is probably a reasonable policy, since the PLT
       marker segments may be removed without losing any information.
   -cpu <coder-iterations>
       Times end-to-end execution and, optionally, the block encoding
       operation, reporting throughput statistics.  If `coder-iterations' is 0,
       the block coder will not be timed, leading to the most accurate
       end-to-end system execution times.  Otherwise, `coder-iterations' must
       be a positive integer -- larger values will result in more accurate
       estimates of the block encoder processing time, but degrade the accuracy
       of end-to-end system execution time estimates.  Note that end-to-end
       times include the impact of image file reading, which can be
       considerable.
   -mem -- Report memory usage.
   -s <switch file>
       Switch to reading arguments from a file.  In the file, argument strings
       are separated by whitespace characters, including spaces, tabs and
       new-line characters.  Comments may be included by introducing a `#' or a
       `%' character, either of which causes the remainder of the line to be
       discarded.  Any number of "-s" argument switch commands may be included
       on the command line.
   -record <file>
       Record code-stream parameters in a file, using the same format which is
       accepted when specifying the parameters on the command line.
   -quiet -- suppress informative messages.
   -version -- print core system version I was compiled against.
   -v -- abbreviation of `-version'
   -usage -- print a comprehensive usage statement.
   -u -- print a brief usage statement."
   
Notes:
       Arguments which commence with an upper case letter (rather than a dash)
   are used to set up code-stream parameter attributes. These arguments have
   the general form:  <arg name>={fld1,fld2,...},{fld1,fld2,...},..., where
   curly braces enclose records and each record is composed of fields.  The
   type and acceptable values for the fields are identified in the usage
   statements, along with whether or not multiple records are allowed.  In the
   special case where only one field is defined per record, the curly braces
   may be omitted. In no event may any spaces appear inside an attribute
   argument.
       Most of the code-stream parameter attributes take an optional
   tile-component modifier, consisting of a colon, followed by a tile
   specifier, a component specifier, or both.  The tile specifier consists of
   the letter `T', followed immediately be the tile index (tiles are numbered
   in raster order, starting from 0).  Similarly, the component specifier
   consists of the letter `C', followed immediately by the component index
   (starting from 0). These modifiers may be used to specify parameter changes
   in specific tiles, components, or tile-components.
       If you do not remember the exact form or description of one of the
   code-stream attribute arguments, simply give the attribute name on the
   command-line and the program will exit with a detailed description of the
   attribute.
       If SIZ parameters are to be supplied explicitly on the command line, be
   aware that these may be affected by simultaneous specification of geometric
   transformations.  If uncertain of the behaviour, use `-record' to determine
   the final compressed code-stream parameters which were used.
       If you are compressing a 3 component image using the reversible or
   irreversible colour transform (this is the default), the program will
   automatically introduce a reasonable set of visual weighting factors, unless
   you use the "Clev_weights" or "Cband_weights" options yourself.  This does
   not happen automatically in the case of single component images, which are
   optimized purely for MSE by default.  To see whether weighting factors were
   used, you may like to use the `-record' option.
